<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Draggable Cubes</title>
<style>
  /* Container where cubes can move */
  .container {
    width: 600px;
    height: 400px;
    border: 2px solid #333;
    position: relative;
    margin: 20px auto;
    background: #f0f0f0;
  }
  /* The cubes */
  .cube {
    width: 100px;
    height: 100px;
    background-color: #4285F4;
    cursor: grab;
    user-select: none;
    position: absolute;
    border-radius: 8px;
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
    transition: box-shadow 0.2s ease;
  }
  .cube.dragging {
    cursor: grabbing;
    box-shadow: 0 8px 12px rgba(0,0,0,0.3);
  }
</style>
</head>
<body>

<div class="container" id="container">
  <div class="cube"></div>
  <div class="cube"></div>
  <div class="cube"></div>
  <div class="cube"></div>
  <div class="cube"></div>
  <div class="cube"></div>
  <div class="cube"></div>
  <div class="cube"></div>
</div>

<script>
  const container = document.getElementById('container');
  const cubes = container.querySelectorAll('.cube');

  let selectedCube = null;
  let offsetX = 0;
  let offsetY = 0;
  let containerRect = container.getBoundingClientRect();

  // Arrange cubes in a grid inside the container using absolute positioning
  function initializeCubes() {
    const cols = 4;
    const cubeSize = 100;
    const gap = 10;
    const padding = 10;
    
    cubes.forEach((cube, index) => {
      let row = Math.floor(index / cols);
      let col = index % cols;
      let left = padding + col * (cubeSize + gap);
      let top = padding + row * (cubeSize + gap);
      
      cube.style.left = left + 'px';
      cube.style.top = top + 'px';
    });
  }

  initializeCubes();

  function onMouseDown(e) {
    if (e.target.classList.contains('cube')) {
      selectedCube = e.target;
      selectedCube.classList.add('dragging');

      containerRect = container.getBoundingClientRect();

      const cubeRect = selectedCube.getBoundingClientRect();
      offsetX = e.clientX - cubeRect.left;
      offsetY = e.clientY - cubeRect.top;

      selectedCube.style.zIndex = 1000;

      e.preventDefault();
    }
  }

  function onMouseMove(e) {
    if (!selectedCube) return;

    let newLeft = e.clientX - containerRect.left - offsetX;
    let newTop = e.clientY - containerRect.top - offsetY;

    const maxLeft = container.clientWidth - selectedCube.offsetWidth;
    const maxTop = container.clientHeight - selectedCube.offsetHeight;

    if (newLeft < 0) newLeft = 0;
    if (newTop < 0) newTop = 0;
    if (newLeft > maxLeft) newLeft = maxLeft;
    if (newTop > maxTop) newTop = maxTop;

    selectedCube.style.left = newLeft + 'px';
    selectedCube.style.top = newTop + 'px';
  }

  function onMouseUp(e) {
    if (selectedCube) {
      selectedCube.classList.remove('dragging');
      selectedCube.style.zIndex = '';
      selectedCube = null;
    }
  }

  container.addEventListener('mousedown', onMouseDown);
  window.addEventListener('mousemove', onMouseMove);
  window.addEventListener('mouseup', onMouseUp);
</script>

</body>
</html>
